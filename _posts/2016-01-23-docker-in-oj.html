---
title: OJ系统中的虚拟化应用
layout: blog
description: 
tags: ['docker', 'python']
---
<div id="mainContent" class="span8">
	<h1 class='text-center'>OJ系统中的虚拟化应用</h1>
	<hr style="border-top:1px solid #aaa;">
	<span class='font_large'><strong>关键词:</strong></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class='muted font_large'>docker</span>
	<span class='muted font_large'>python</span>
	<hr style="border-top:2px solid #aaa;">

<p>最近在重新开发一个在线编程系统，之前系统也在另一篇<a href="">blog</a>中有提到，这类系统的核心在于判题机制，即用户在提交后如何对提交代码进行<strong>安全</strong>判题。</p>

<p>在最开始的系统中，是直接将提交的代码保存成文件后新开一个进程执行，同时禁止使用一些系统模块，例如<code>os</code>，<code>sys</code>等，但这是一个很粗糙的方案，根本原因在于代码依然对服务器主机有访问权限，如果是root执行那就更危险了。</p>

<p>在后来的量化系统中，因为执行是通过类实例来运行算法，所以这方面和判题就没有太大关系，但这也有个问题，代码运行没有限制，限制包括对CPU，内存，运行时间等，如果在用户提交代码中有恶意代码，死循环，fork炸弹等，就会引起运行崩溃。所以这又是一个问题。</p>

<h3 id="toc_0">架构</h3>

<p>所以在最新的OJ系统2.0中，我们引入了虚机隔离，资源限制的策略：</p>

<ul>
<li>虚机隔离 是指用户注册后，会对应创建一个虚机环境，这个环境包含了程序运行需要的第三方库等，目前虚机是采用的docker作为容器，这样在一个基本的服务器上有上百个容器实例也是足够支撑的。而且由于有心跳包检测等，所以实际同时运行的容器并不会达到峰值。</li>
<li>资源限制 是指在虚机内部为防止恶意代码，采用lrun作为资源限制，lrun本质上也是通过cgroups来进行资源控制，举个例子，提交代码希望能在限制的时间内完成，如果超时即终止，这样就可以保证代码不会恶意执行而一直占用资源。</li>
</ul>

<p>下面是具体的一个架构图</p>

<img src="{{ site.url }}/assets/post_imgs/docker_in_oj/oj_arch.png" />

<p>可以看到，这张图除了介绍的虚机外，还有队列服务器，这是为了保证在提交代码后不至于一直等待而设计的异步消息服务，每次提交后封装成一个任务并加入到队列中，用户端则可以直接返回。如果一直停留在提交页面那么会有一个定时轮询来更新提交状态，如果关闭或刷新页面，则这次提交也会后台执行。</p>

<h3 id="toc_1">技术说明</h3>

<p>介绍完架构下面说下一些用到的技术框架等。</p>

<p>整个系统Python开发，采用Django作为Web框架，使用Django的好处在于成熟，虽然ORM部分没有sqlalchemy那么好用但对于简单的操作也是足够了，毕竟这个系统也不是需要特别复杂的数据库操作。django的缺点在于效率，一个是执行效率，这个和python语言本身有关，还有一个就是项目规模扩大后的不易于管理。不过这些暂时不是最需要考虑的。</p>

<p>消息队列采用的是django-celery, Broker在开发调试的时候用的是django本身做服务器，在正式环境下采用的是redis作为服务器。这里需要在配置文件中指明redis的数据库，默认是0，这些都在配置文件中有体现。</p>

<p>资源隔离采用的是lrun，这也是一个github上的开源项目，关键是比较简单，安装后只需要简单的命令即可，不需要过多涉及底层的cgroups命令。</p>

<p>最重要的虚机环境，采用的是docker，具体的docker介绍可以参考之前的系列文章。这里镜像基于官方ubuntu:14.04 镜像，配置了必要的库后自己定制的，出于网络问题就没有commit到docker hub上。在每个用户注册后都会创建一个挂载了用户自己目录的私有虚机，在每次登陆后在线时即启动，通过心跳包来保证容器运行。如果用户退出或关闭页面一段时间，容器都会关闭以节约资源。docker的python sdk是docker-py，目前来看使用还可以，支持基本的docker命令，一些坑可以参考之前的文章，如果有深入而满足不了的话还可以考虑使用纯的命令行来直接操纵docker。</p>

<p>在提交代码后，提交封装成任务，由队列分发到对应虚机中执行，执行由lrun进行资源控制，结束后更新任务状态和执行结果。如果用户有状态轮询也会反映在用户界面上。</p>

<h3 id="toc_2">总结</h3>

<p>在传统的oj系统中，核心在于判题机制，需要考虑到各种方面来完善判题机制，针对可能出现的问题进行环境隔离、资源限制等，而虚拟化的出现则比较好的解决了这类问题，不同于沉重的VM，docker虚拟化比较轻量，在一个基本的服务器上也可以部署多数量的实例，如果压力过大还可以多服务器分担。之前在网上查找的资料显示一台32G内存的服务器可以支持2g内存的docker容器1000个实例(？待证实，不是很确定)，和传统的VM相比大大减轻了压力。隔离性保证了用户之间不会有影响，同时如果单用户希望能提高虚机配置也比较方便，在虚机内部再加上资源限制这样就构成了一个判题环境，只是目前虚机对于文件共享是直接挂载，这个和docker的aufs文件系统有关，后续如果有更好的解决方案的话可以再尝试看看。</p>


</div>